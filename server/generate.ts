import { parseExportNames } from "https://deno.land/x/aleph_compiler@0.1.0/mod.ts";
import type { Route } from "../framework/core/route.ts";

/** generate the `routes.gen.ts` follow the routes config */
export async function generate(routes: Route[]) {
  const routeFiles = await Promise.all(routes.map(async ([_, { filename }]) => {
    const code = await Deno.readTextFile(filename);
    const exportNames = await parseExportNames(filename, code);
    return [filename, exportNames];
  }));

  const imports: string[] = [];
  const revives: string[] = [];

  routeFiles.forEach(([filename, exportNames], idx) => {
    const hasDefaultExport = exportNames.includes("default");
    const hasDataExport = exportNames.includes("data");
    if (!hasDefaultExport && !hasDataExport) {
      return [];
    }
    imports.push(`import { ${
      [
        hasDefaultExport && `default as $${idx}`,
        hasDataExport && `data as $$${idx}`,
      ].filter(Boolean).join(", ")
    } } from ${JSON.stringify(filename)};`);
    revives.push(`revive(${JSON.stringify(filename)}, { ${
      [
        hasDefaultExport && `default: $${idx}`,
        hasDataExport && `data: $$${idx}`,
      ].filter(Boolean).join(", ")
    } });`);
  });

  if (imports.length) {
    const code = [
      "/*! Generated by Aleph.js, do **NOT** change and ensure the file is **NOT** in the `.gitignore`. */",
      "",
      `import { revive } from "aleph/server";`,
      ...imports,
      "",
      ...revives,
    ].join("\n");
    await Deno.writeTextFile("routes.gen.ts", code);

    const serverEntry = Deno.env.get("ALEPH_SERVER_ENTRY");
    if (serverEntry) {
      const code = await Deno.readTextFile(serverEntry);
      if (!code.includes(`import "./routes.gen.ts"`)) {
        await Deno.writeTextFile(serverEntry, `import "./routes.gen.ts"\n${code}`);
      }
    }
  }
}
